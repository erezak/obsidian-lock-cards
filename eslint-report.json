[{"filePath":"/Users/ek844y/vaults/Work/.obsidian/plugins/lock-cards/src/main.ts","messages":[{"ruleId":"@typescript-eslint/no-unnecessary-type-assertion","severity":2,"message":"This assertion is unnecessary since it does not change the type of the expression.","line":81,"column":16,"nodeType":"TSAsExpression","messageId":"unnecessaryAssertion","endLine":81,"endColumn":68,"fix":{"range":[2671,2682],"text":""}}],"suppressedMessages":[{"ruleId":"no-console","severity":2,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, debug.","line":149,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":149,"endColumn":20,"suggestions":[{"fix":{"range":[4798,4879],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, debug.","line":171,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":171,"endColumn":16,"suggestions":[{"fix":{"range":[5513,5548],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement. Only these console methods are allowed: warn, error, debug.","line":176,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":176,"endColumn":16,"suggestions":[{"fix":{"range":[5606,5643],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/* eslint-disable no-console */\nimport { Notice, Plugin } from \"obsidian\";\nimport { DEFAULT_SETTINGS, LockCardsSettingTab, type LockCardsSettings } from \"./settings\";\n\ntype LockedByCanvas = Record<string, string[]>; // canvasPath -> nodeIds\n\ntype PluginDataV1 = {\n  version: 1;\n  lockedByCanvas: LockedByCanvas;\n  settings: LockCardsSettings;\n};\n\ninterface CanvasViewLike {\n  getViewType(): string;\n  containerEl: HTMLElement;\n  file?: { path: string };\n}\n\ntype CanvasLike = {\n  selection?: unknown;\n  nodes?: unknown;\n};\n\ntype ModelSnapshot = {\n  mode: \"top\" | \"pos\" | \"rect\" | \"data\" | \"unknown\";\n  x: number;\n  y: number;\n  w?: number;\n  h?: number;\n};\n\nfunction isCanvasViewLike(v: unknown): v is CanvasViewLike {\n  if (!v || typeof v !== \"object\") return false;\n  const obj = v as Record<string, unknown>;\n  return typeof obj.getViewType === \"function\" && obj.containerEl instanceof HTMLElement;\n}\n\nfunction isRecord(v: unknown): v is Record<string, unknown> {\n  return Boolean(v) && typeof v === \"object\";\n}\n\nfunction getCanvasFromView(view: CanvasViewLike): CanvasLike | null {\n  const v = view as unknown as Record<string, unknown>;\n  const canvas = v[\"canvas\"];\n  if (!canvas || typeof canvas !== \"object\") return null;\n  return canvas as CanvasLike;\n}\n\nexport default class LockCardsPlugin extends Plugin {\n  private lockedByCanvas: LockedByCanvas = {};\n  settings: LockCardsSettings = { ...DEFAULT_SETTINGS };\n\n  // Movement blocking\n  private lockedStyleByCanvas: Record<string, Record<string, string>> = {};\n  private lockedModelByCanvas: Record<string, Record<string, ModelSnapshot>> = {};\n\n  private observer: MutationObserver | null = null;\n  private observedCanvasPath: string | null = null;\n  private observedView: CanvasViewLike | null = null;\n\n  private lastRestoreAtByCanvas: Record<string, Record<string, number>> = {};\n\n  private altDown = false;\n  private restoring = new WeakSet<HTMLElement>();\n\n  // Your DOM does not expose node id, so we keep our own mapping.\n  private nodeIdByEl = new WeakMap<HTMLElement, string>();\n\n  async onload() {\n    const loaded: unknown = await this.loadData();\n\n    if (loaded && typeof loaded === \"object\") {\n      const maybe = loaded as Partial<PluginDataV1> & Record<string, unknown>;\n\n      if (typeof maybe.version === \"number\" && (maybe as { version?: unknown }).version === 1) {\n        this.lockedByCanvas = (maybe.lockedByCanvas as LockedByCanvas) ?? {};\n\n        const loadedSettings = isRecord(maybe.settings) ? maybe.settings : {};\n        const disableLockWhileAltDown =\n          typeof loadedSettings[\"disableLockWhileAltDown\"] === \"boolean\"\n            ? (loadedSettings[\"disableLockWhileAltDown\"] as boolean)\n            : DEFAULT_SETTINGS.disableLockWhileAltDown;\n\n        this.settings = {\n          ...DEFAULT_SETTINGS,\n          disableLockWhileAltDown,\n        };\n      } else {\n        // Back-compat: older data stored just the locked map.\n        this.lockedByCanvas = loaded as LockedByCanvas;\n        this.settings = { ...DEFAULT_SETTINGS };\n      }\n    }\n\n    this.addSettingTab(new LockCardsSettingTab(this.app, this));\n\n    this.installAltKeyTracking();\n\n    this.addCommand({\n      id: \"toggle-lock-selected-cards\",\n      name: \"Toggle lock for selected canvas cards\",\n      callback: () => {\n        const ctx = this.getActiveCanvasContext();\n        if (!ctx) {\n          new Notice(\"Open a canvas first.\");\n          return;\n        }\n\n        this.attachStyleGuardToCanvas(ctx.view, ctx.canvasPath);\n\n        const selectedIds = this.getSelectedCanvasNodeIdsFromInternalSelection(ctx.view);\n        if (selectedIds.length === 0) {\n          new Notice(\"Select one or more canvas cards first.\");\n          return;\n        }\n\n        const anyUnlocked = selectedIds.some((id) => !this.isLocked(ctx.canvasPath, id));\n        const newLockedState = anyUnlocked;\n\n        for (const id of selectedIds) {\n          this.setLocked(ctx.canvasPath, id, newLockedState);\n        }\n\n        for (const id of selectedIds) {\n          const el = this.resolveNodeElById(ctx.view, id);\n          if (!el) continue;\n\n          if (newLockedState) {\n            this.nodeIdByEl.set(el, id);\n\n            // Snapshot DOM style and internal model position\n            this.snapshotLockedNodeStyle(ctx.canvasPath, id, el);\n            this.snapshotLockedNodeModel(ctx.view, ctx.canvasPath, id);\n          } else {\n            this.forgetLockedNodeStyle(ctx.canvasPath, id);\n            this.forgetLockedNodeModel(ctx.canvasPath, id);\n          }\n        }\n\n        this.applyLockedClasses(ctx.view, ctx.canvasPath);\n\t\t\t\tvoid this.savePluginData();\n\n        new Notice(\n          newLockedState\n            ? `Locked ${selectedIds.length} card(s).`\n            : `Unlocked ${selectedIds.length} card(s).`,\n        );\n\n        console.log(\"[lock-cards]\", newLockedState ? \"locked\" : \"unlocked\", selectedIds);\n      },\n    });\n\n    this.registerEvent(\n      this.app.workspace.on(\"active-leaf-change\", () => {\n        const ctx = this.getActiveCanvasContext();\n        if (!ctx) return;\n\n        this.attachStyleGuardToCanvas(ctx.view, ctx.canvasPath);\n        this.applyLockedClasses(ctx.view, ctx.canvasPath);\n        this.primeLockedSnapshots(ctx.view, ctx.canvasPath);\n      }),\n    );\n\n    const ctx = this.getActiveCanvasContext();\n    if (ctx) {\n      this.attachStyleGuardToCanvas(ctx.view, ctx.canvasPath);\n      this.applyLockedClasses(ctx.view, ctx.canvasPath);\n      this.primeLockedSnapshots(ctx.view, ctx.canvasPath);\n    }\n\n    console.log(\"[lock-cards] loaded\");\n  }\n\n  onunload() {\n    this.observer?.disconnect();\n    console.log(\"[lock-cards] unloaded\");\n  }\n\n  async saveSettings() {\n    await this.savePluginData();\n  }\n\n  private async savePluginData() {\n    const data: PluginDataV1 = {\n      version: 1,\n      lockedByCanvas: this.lockedByCanvas,\n      settings: this.settings,\n    };\n\n    await this.saveData(data);\n  }\n\n  private getActiveCanvasContext(): { view: CanvasViewLike; canvasPath: string } | null {\n    const tryLeaf = (leaf: unknown): CanvasViewLike | null => {\n      if (!leaf || typeof leaf !== \"object\") return null;\n      const l = leaf as { view?: unknown };\n      if (!isCanvasViewLike(l.view)) return null;\n      if (l.view.getViewType() !== \"canvas\") return null;\n      return l.view;\n    };\n\n    const ws = this.app.workspace as unknown as Record<string, unknown>;\n    const activeLeaf = ws[\"activeLeaf\"];\n\n    const candidates: unknown[] = [\n      activeLeaf,\n      this.app.workspace.getMostRecentLeaf(),\n      ...this.app.workspace.getLeavesOfType(\"canvas\"),\n    ].filter((x) => Boolean(x));\n\n    for (const leaf of candidates) {\n      const view = tryLeaf(leaf);\n      if (!view) continue;\n\n      const canvasPath = view.file?.path;\n      if (!canvasPath) continue;\n\n      return { view, canvasPath };\n    }\n\n    return null;\n  }\n\n  private getSelectedCanvasNodeIdsFromInternalSelection(view: CanvasViewLike): string[] {\n    const canvas = getCanvasFromView(view);\n    if (!canvas) return [];\n\n    const sel = canvas.selection;\n    if (!sel) return [];\n\n    const out: string[] = [];\n\n    if (sel instanceof Set) {\n      for (const item of sel) {\n        if (typeof item === \"string\") out.push(item);\n        else if (item && typeof item === \"object\") {\n          const maybeId = (item as { id?: unknown }).id;\n          if (typeof maybeId === \"string\") out.push(maybeId);\n        }\n      }\n      return out;\n    }\n\n    if (typeof sel === \"object\") {\n      const obj = sel as Record<string, unknown>;\n      for (const key of [\"nodes\", \"selectedNodes\", \"items\"]) {\n        const v = obj[key];\n        if (v instanceof Set) {\n          for (const item of v) {\n            if (typeof item === \"string\") out.push(item);\n          }\n          if (out.length > 0) return out;\n        }\n        if (Array.isArray(v)) {\n          for (const item of v) {\n            if (typeof item === \"string\") out.push(item);\n            else if (item && typeof item === \"object\") {\n              const maybeId = (item as { id?: unknown }).id;\n              if (typeof maybeId === \"string\") out.push(maybeId);\n            }\n          }\n          if (out.length > 0) return out;\n        }\n      }\n\n      const maybeIterable = sel as Partial<Iterable<unknown>>;\n      const maybeIter = maybeIterable[Symbol.iterator];\n      if (typeof maybeIter === \"function\") {\n        for (const item of sel as Iterable<unknown>) {\n          if (typeof item === \"string\") out.push(item);\n          else if (item && typeof item === \"object\") {\n            const maybeId = (item as { id?: unknown }).id;\n            if (typeof maybeId === \"string\") out.push(maybeId);\n          }\n        }\n        if (out.length > 0) return out;\n      }\n    }\n\n    return [];\n  }\n\n  private resolveNodeElById(view: CanvasViewLike, id: string): HTMLElement | null {\n    const canvas = getCanvasFromView(view);\n\n    // Attempt 1: internal nodes map\n    const nodes = canvas?.nodes;\n    if (nodes instanceof Map) {\n      const nodeObj = nodes.get(id) as unknown;\n      if (nodeObj && typeof nodeObj === \"object\") {\n        const o = nodeObj as Record<string, unknown>;\n        const candidates = [o[\"nodeEl\"], o[\"el\"], o[\"containerEl\"], o[\"contentEl\"]];\n        for (const c of candidates) {\n          if (c instanceof HTMLElement) {\n            const nodeEl = c.classList.contains(\"canvas-node\")\n              ? c\n              : c.closest<HTMLElement>(\".canvas-node\");\n            if (nodeEl) {\n              this.nodeIdByEl.set(nodeEl, id);\n              return nodeEl;\n            }\n          }\n        }\n      }\n    }\n\n    // Attempt 2: DOM attributes (may not exist in your build)\n    const container = view.containerEl;\n    const selectors = [\n      `.canvas-node[data-node-id=\"${id}\"]`,\n      `.canvas-node[data-id=\"${id}\"]`,\n      `.canvas-node[data-node=\"${id}\"]`,\n      `.canvas-node[data-uid=\"${id}\"]`,\n      `#${CSS.escape(id)}`,\n    ];\n\n    for (const sel of selectors) {\n      const el = container.querySelector<HTMLElement>(sel);\n      if (el) {\n        const nodeEl = el.classList.contains(\"canvas-node\")\n          ? el\n          : el.closest<HTMLElement>(\".canvas-node\");\n        if (nodeEl) {\n          this.nodeIdByEl.set(nodeEl, id);\n          return nodeEl;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  private applyLockedClasses(view: CanvasViewLike, canvasPath: string) {\n    const container = view.containerEl;\n\n    for (const node of Array.from(container.querySelectorAll<HTMLElement>(\".canvas-node\"))) {\n      node.classList.remove(\"lc-locked\");\n    }\n\n    const lockedIds = this.lockedByCanvas[canvasPath] ?? [];\n    for (const id of lockedIds) {\n      const el = this.resolveNodeElById(view, id);\n      if (el) el.classList.add(\"lc-locked\");\n    }\n  }\n\n  private isLocked(canvasPath: string, nodeId: string): boolean {\n    return (this.lockedByCanvas[canvasPath] ?? []).includes(nodeId);\n  }\n\n  private setLocked(canvasPath: string, nodeId: string, locked: boolean) {\n    const current = new Set(this.lockedByCanvas[canvasPath] ?? []);\n    if (locked) current.add(nodeId);\n    else current.delete(nodeId);\n    this.lockedByCanvas[canvasPath] = Array.from(current);\n  }\n\n  private snapshotLockedNodeStyle(canvasPath: string, nodeId: string, nodeEl: HTMLElement) {\n    if (!this.lockedStyleByCanvas[canvasPath]) this.lockedStyleByCanvas[canvasPath] = {};\n    this.lockedStyleByCanvas[canvasPath][nodeId] = nodeEl.getAttribute(\"style\") ?? \"\";\n  }\n\n  private forgetLockedNodeStyle(canvasPath: string, nodeId: string) {\n    const map = this.lockedStyleByCanvas[canvasPath];\n    if (!map) return;\n    delete map[nodeId];\n  }\n\n  private snapshotLockedNodeModel(view: CanvasViewLike, canvasPath: string, nodeId: string) {\n    const snap = this.readModelSnapshot(view, nodeId);\n    if (!snap) return;\n    if (!this.lockedModelByCanvas[canvasPath]) this.lockedModelByCanvas[canvasPath] = {};\n    this.lockedModelByCanvas[canvasPath][nodeId] = snap;\n  }\n\n  private forgetLockedNodeModel(canvasPath: string, nodeId: string) {\n    const map = this.lockedModelByCanvas[canvasPath];\n    if (!map) return;\n    delete map[nodeId];\n  }\n\n  private primeLockedSnapshots(view: CanvasViewLike, canvasPath: string) {\n    const lockedIds = this.lockedByCanvas[canvasPath] ?? [];\n    if (lockedIds.length === 0) return;\n\n    for (const id of lockedIds) {\n      if (this.lockedStyleByCanvas[canvasPath]?.[id] === undefined) {\n        const el = this.resolveNodeElById(view, id);\n        if (el) this.snapshotLockedNodeStyle(canvasPath, id, el);\n      }\n\n      if (this.lockedModelByCanvas[canvasPath]?.[id] === undefined) {\n        this.snapshotLockedNodeModel(view, canvasPath, id);\n      }\n    }\n  }\n\n  private readModelSnapshot(view: CanvasViewLike, nodeId: string): ModelSnapshot | null {\n    const canvas = getCanvasFromView(view);\n    const nodes = canvas?.nodes;\n    if (!(nodes instanceof Map)) return null;\n\n    const nodeObj = nodes.get(nodeId) as unknown;\n    if (!nodeObj || typeof nodeObj !== \"object\") return null;\n\n    const o = nodeObj as Record<string, unknown>;\n\n    const fromObj = (base: unknown, mode: ModelSnapshot[\"mode\"]): ModelSnapshot | null => {\n      if (!base || typeof base !== \"object\") return null;\n      const b = base as Record<string, unknown>;\n      const x = b[\"x\"];\n      const y = b[\"y\"];\n      if (typeof x !== \"number\" || typeof y !== \"number\") return null;\n\n      const w = b[\"width\"];\n      const h = b[\"height\"];\n      const w2 = b[\"w\"];\n      const h2 = b[\"h\"];\n\n      return {\n        mode,\n        x,\n        y,\n        w: typeof w === \"number\" ? w : typeof w2 === \"number\" ? w2 : undefined,\n        h: typeof h === \"number\" ? h : typeof h2 === \"number\" ? h2 : undefined,\n      };\n    };\n\n    // Try common locations\n    return (\n      fromObj(o, \"top\") ||\n      fromObj(o[\"pos\"], \"pos\") ||\n      fromObj(o[\"rect\"], \"rect\") ||\n      fromObj(o[\"data\"], \"data\") ||\n      null\n    );\n  }\n\n  private restoreModelSnapshot(view: CanvasViewLike, nodeId: string, snap: ModelSnapshot) {\n    const canvas = getCanvasFromView(view);\n    const nodes = canvas?.nodes;\n    if (!(nodes instanceof Map)) return;\n\n    const nodeObj = nodes.get(nodeId) as unknown;\n    if (!nodeObj || typeof nodeObj !== \"object\") return;\n\n    const o = nodeObj as Record<string, unknown>;\n\n    const applyTo = (base: unknown): boolean => {\n      if (!base || typeof base !== \"object\") return false;\n      const b = base as Record<string, unknown>;\n\n      if (typeof b[\"x\"] === \"number\") b[\"x\"] = snap.x;\n      else return false;\n\n      if (typeof b[\"y\"] === \"number\") b[\"y\"] = snap.y;\n      else return false;\n\n      if (snap.w !== undefined) {\n        if (typeof b[\"width\"] === \"number\") b[\"width\"] = snap.w;\n        else if (typeof b[\"w\"] === \"number\") b[\"w\"] = snap.w;\n      }\n\n      if (snap.h !== undefined) {\n        if (typeof b[\"height\"] === \"number\") b[\"height\"] = snap.h;\n        else if (typeof b[\"h\"] === \"number\") b[\"h\"] = snap.h;\n      }\n\n      return true;\n    };\n\n    // Prefer the same structure we captured from, fallback to others.\n    const bases: unknown[] =\n      snap.mode === \"top\"\n        ? [o, o[\"pos\"], o[\"rect\"], o[\"data\"]]\n        : snap.mode === \"pos\"\n          ? [o[\"pos\"], o, o[\"rect\"], o[\"data\"]]\n          : snap.mode === \"rect\"\n            ? [o[\"rect\"], o, o[\"pos\"], o[\"data\"]]\n            : snap.mode === \"data\"\n              ? [o[\"data\"], o, o[\"pos\"], o[\"rect\"]]\n              : [o, o[\"pos\"], o[\"rect\"], o[\"data\"]];\n\n    for (const base of bases) {\n      if (applyTo(base)) break;\n    }\n\n    // If the node or canvas has a render method, ask for a refresh.\n    const maybeMethods = [\"requestRender\", \"requestFrame\", \"render\", \"redraw\"];\n    const canvasObj = canvas as unknown as Record<string, unknown>;\n    for (const m of maybeMethods) {\n      const fn = canvasObj[m];\n      if (typeof fn === \"function\") {\n        try {\n          (fn as () => void)();\n          break;\n        } catch {\n          // ignore\n        }\n      }\n    }\n  }\n\n  private installAltKeyTracking() {\n    const onKeyDown = (e: KeyboardEvent) => {\n      if (e.key === \"Alt\") this.altDown = true;\n    };\n    const onKeyUp = (e: KeyboardEvent) => {\n      if (e.key === \"Alt\") this.altDown = false;\n    };\n\n    document.addEventListener(\"keydown\", onKeyDown, true);\n    document.addEventListener(\"keyup\", onKeyUp, true);\n\n    this.register(() => {\n      document.removeEventListener(\"keydown\", onKeyDown, true);\n      document.removeEventListener(\"keyup\", onKeyUp, true);\n    });\n  }\n\n  private attachStyleGuardToCanvas(view: CanvasViewLike, canvasPath: string) {\n    if (this.observer && this.observedCanvasPath === canvasPath) return;\n\n    this.observer?.disconnect();\n    this.observer = null;\n\n    this.observedCanvasPath = canvasPath;\n    this.observedView = view;\n\n    const container = view.containerEl;\n\n    const isSameSnapshot = (a: ModelSnapshot, b: ModelSnapshot): boolean => {\n      const eps = 0.0001;\n      const close = (x: number, y: number) => Math.abs(x - y) <= eps;\n\n      if (!close(a.x, b.x) || !close(a.y, b.y)) return false;\n\n      const aw = a.w;\n      const bw = b.w;\n      if (aw === undefined || bw === undefined) {\n        if (aw !== bw) return false;\n      } else if (!close(aw, bw)) return false;\n\n      const ah = a.h;\n      const bh = b.h;\n      if (ah === undefined || bh === undefined) {\n        if (ah !== bh) return false;\n      } else if (!close(ah, bh)) return false;\n\n      return true;\n    };\n\n    const shouldThrottleRestore = (nodeId: string): boolean => {\n      if (!this.lastRestoreAtByCanvas[canvasPath]) this.lastRestoreAtByCanvas[canvasPath] = {};\n      const now = Date.now();\n      const last = this.lastRestoreAtByCanvas[canvasPath][nodeId] ?? 0;\n      if (now - last < 50) return true;\n      this.lastRestoreAtByCanvas[canvasPath][nodeId] = now;\n      return false;\n    };\n\n    const restorePositionStyleOnly = (nodeEl: HTMLElement, savedStyle: string) => {\n      // Only restore position/size-related props; do not clobber the entire inline style.\n      const tmp = document.createElement(\"div\");\n      tmp.setAttribute(\"style\", savedStyle);\n      const saved = tmp.style;\n      const current = nodeEl.style;\n\n      const props = [\"left\", \"top\", \"width\", \"height\", \"transform\"] as const;\n\n      for (const prop of props) {\n        const v = saved.getPropertyValue(prop);\n        if (v) current.setProperty(prop, v);\n        else current.removeProperty(prop);\n      }\n    };\n\n    this.observer = new MutationObserver((mutations) => {\n\t\t\tif (this.settings.disableLockWhileAltDown && this.altDown) return;\n      if (!this.observedView) return;\n\n      for (const m of mutations) {\n        if (m.type !== \"attributes\") continue;\n\n        const target = m.target;\n        if (!(target instanceof HTMLElement)) continue;\n\n        const nodeEl = target.classList.contains(\"canvas-node\")\n          ? target\n          : target.closest<HTMLElement>(\".canvas-node\");\n\n        if (!nodeEl) continue;\n        if (!nodeEl.classList.contains(\"lc-locked\")) continue;\n\n        // Ignore style mutations on descendants; Canvas uses these for handles/UX.\n        // We only care about the node element itself moving/resizing.\n        if (target !== nodeEl) continue;\n\n        const nodeId = this.nodeIdByEl.get(nodeEl);\n        if (!nodeId) continue;\n\n        const savedStyle = this.lockedStyleByCanvas[canvasPath]?.[nodeId];\n        const savedModel = this.lockedModelByCanvas[canvasPath]?.[nodeId];\n\n        if (savedStyle === undefined && savedModel === undefined) continue;\n\n        if (this.restoring.has(nodeEl)) continue;\n\n        this.restoring.add(nodeEl);\n\n        try {\n          if (savedModel && this.observedView) {\n            const currentModel = this.readModelSnapshot(this.observedView, nodeId);\n            // Only restore if the model's x/y/size actually changed.\n            if (!currentModel || !isSameSnapshot(currentModel, savedModel)) {\n              if (!shouldThrottleRestore(nodeId)) {\n                this.restoreModelSnapshot(this.observedView, nodeId, savedModel);\n              }\n            }\n          } else if (savedStyle !== undefined) {\n            // Fallback: restore only position/size props.\n            restorePositionStyleOnly(nodeEl, savedStyle);\n          }\n        } finally {\n          queueMicrotask(() => this.restoring.delete(nodeEl));\n        }\n      }\n    });\n\n    this.observer.observe(container, {\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"style\"],\n    });\n\n    this.register(() => this.observer?.disconnect());\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/ek844y/vaults/Work/.obsidian/plugins/lock-cards/src/settings.ts","messages":[{"ruleId":"obsidianmd/ui/sentence-case","severity":2,"message":"Use sentence case for UI text.","line":29,"column":13,"nodeType":"Literal","messageId":"useSentenceCase","endLine":29,"endColumn":45},{"ruleId":"obsidianmd/ui/sentence-case","severity":2,"message":"Use sentence case for UI text.","line":30,"column":13,"nodeType":"Literal","messageId":"useSentenceCase","endLine":30,"endColumn":68}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { App, PluginSettingTab, Setting, type Plugin } from \"obsidian\";\n\nexport interface LockCardsSettings {\n\tdisableLockWhileAltDown: boolean;\n}\n\nexport const DEFAULT_SETTINGS: LockCardsSettings = {\n\tdisableLockWhileAltDown: true,\n};\n\nexport type LockCardsPluginLike = Plugin & {\n\tsettings: LockCardsSettings;\n\tsaveSettings: () => Promise<void>;\n};\n\nexport class LockCardsSettingTab extends PluginSettingTab {\n\tplugin: LockCardsPluginLike;\n\n\tconstructor(app: App, plugin: LockCardsPluginLike) {\n\t\tsuper(app, plugin);\n\t\tthis.plugin = plugin;\n\t}\n\n\tdisplay(): void {\n\t\tconst { containerEl } = this;\n\t\tcontainerEl.empty();\n\n\t\tnew Setting(containerEl)\n\t\t\t.setName(\"Disable lock while Alt is held\")\n\t\t\t.setDesc(\"Temporarily allow moving locked cards by holding Alt.\")\n\t\t\t.addToggle((toggle) =>\n\t\t\t\ttoggle\n\t\t\t\t\t.setValue(this.plugin.settings.disableLockWhileAltDown)\n\t\t\t\t\t.onChange(async (value) => {\n\t\t\t\t\t\tthis.plugin.settings.disableLockWhileAltDown = value;\n\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t}),\n\t\t\t);\n\t}\n}\n","usedDeprecatedRules":[]}]